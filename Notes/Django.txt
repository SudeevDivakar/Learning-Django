DJANGO:
-> Python web developement framework.
-> Whatever happens in the frontend will be the same (HTML, CSS, Javascript)
-> Framework is a third party module which we install on our system 
-> We use it's utility functionalities and methods (for managing sessions, authentication, file uploads)
-> It's called a framework as it not only provides us tools to use but also provides guidance on how to use them.
-> Built for Python 3.x (latest version of python)
-> Batteries included approach (offers built-in solutions and features for basically all problems)
-> Can also be customizable and extensible


NOTE: To list all the installed packages in pip, do:
e.g) pip list


CREATING A DJANGO PROJECT:
-> To create a django project, run
e.g)
django-admin startproject <project_name>



ANALYZING THE CREATED PROJECT:
-> The manage.py file should not be touched.
-> The manage.py file gives us access to built in django commands.
-> The __init__.py file is empty and it's only purpose is to make the folder a python module(package).
-> The asgi.py and wsgi.py python files are used while deploying the project.
-> The setting.py and the urls.py files are the files which we are allowed to edit.
-> The db.sqlite3 file is a dummy database we can use.



STARTING A DEVELOPMENT SERVER:
-> To start a developement server we do:
e.g)
python manage.py runserver
            (OR)
python3 manage.py runserver



DJANGO APPS:
-> To handle different functionalities in our project, we use django apps(This follows a modular structure).
-> To create an app, do:
e.g)
python manage.py startapp <app_name>
-> Each app acts as a singular microservice.



ANALYZING THE CREATED APP:
-> The migrations folder is empty but is important for databases and models.
-> The admin.py file comes in handy when dealing with the administration part of the project.
-> The apps.py file configures the app created. It is needed when we want to connect multiple apps.
-> The models.py file is also important for databases and models.
-> The tests.py file helps with automated testing and unit tests.
-> The views.py file has logic which determines what we show to the user.



GITIGNORE FILE FOR DJANGO:
-> Add all requirements to a requirements.txt file.
-> Add the name of the virtual environment to the .gitignore file
e.g)
venv/



CREATING VIEWS AND URLS:
-> To create views, we write functions in the views.py file.
-> This function recieves a parameter (request) which contains the request information.
-> We return a response from this function using the HttpResponse method.
e.g)
from django.shortcuts import render
from django.http import HttpResponse

# Create your views here.

def index(request):
    return HttpResponse('This works')

-> To specify urls, we create a new file called urls.py and add the urls to a list.
-> Each element of this list will be converted into a valid path using the path method.
-> The first parameter to this path method is the url path which we want to specify and the second is the corresponding function that will be triggered from the views.py file.
e.g)
from django.urls import path
from . import views

urlpatterns = [
    path("january", views.index)
]

-> We then connect the urls from each app to the main project folder.
e.g)
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('challenges/', include("challenges.urls"))
]


DYNAMIC PATH SEGMENTS:
-> To set up a dynamic path segment, in the urlpatterns list of the app, enclose the variable path name inside <> brackets.
e.g)
urlpatterns = [
    path("<month>", views.monthly_challenge)
]
-> In the views.py file, we accept an additional parameter with the same name as the variable path
e.g)
def monthly_challenge(request, month):
    if month == 'january':
        return HttpResponse('Eat more protein')
    elif month == 'february':
        return HttpResponse('Drink more water')
    elif month == 'march':
        return HttpResponse('Go to gym more')
    else:
        return HttpResponseNotFound('This month is not supported')


THROWING NOT FOUND ERRORS:
-> To do this, just import the HttpResponseNotFound function and return the appropriate message in that.
e.g)
from django.shortcuts import render
from django.http import HttpResponse, HttpResponseNotFound
def monthly_challenge(request, month):
    if month == 'january':
        return HttpResponse('Eat more protein')
    elif month == 'february':
        return HttpResponse('Drink more water')
    elif month == 'march':
        return HttpResponse('Go to gym more')
    else:
        return HttpResponseNotFound('This month is not supported')


PATH CONVERTERS:
-> To convert the variable paths into a specific type we can use path converters.
-> To use these path parameters we can specify the datatype before the path variables:
e.g)
urlpatterns = [
    path("<int:month>", views.monthly_challenge_by_number),
    path("<str:month>", views.monthly_challenge)
]


REDIRECTING:
-> To redirect to a different URL, we use the HttpResponseRedirect function to redirect to the required URL.
e.g)
from django.shortcuts import render
from django.http import HttpResponse, HttpResponseNotFound, HttpResponseRedirect

def monthly_challenge_by_number(request, month):
    try:
        months = list(monthly_challenges.keys())
        redirectMonth = months[month-1]
        return HttpResponseRedirect("/challenges/" + redirectMonth)
    except:
        return HttpResponseNotFound('This month is not supported')



REVERSE FUNCTIONS AND NAMED URLS:
-> In case the main URL changes and we try to redirect to a URL that does exist (has been changed), then this would result in an error.
-> To avoid this error, we give the URLs a name and use the reverse function to build a URL for this name.
-> We can provide a name for these URLs by passing in a third argument to the path function in urls.py
e.g)
from django.urls import path
from . import views

urlpatterns = [
    path("<int:month>", views.monthly_challenge_by_number),
    path("<str:month>", views.monthly_challenge, name="month-challenge")
]

-> To build a URL for a specific named URL, we use the reverse function.
-> The first argument to this reverse function is the name of the URL. The second argument is a list of args which contains values for variable path params.
e.g)
from django.shortcuts import render
from django.http import HttpResponse, HttpResponseNotFound, HttpResponseRedirect
from django.urls import reverse

def monthly_challenge_by_number(request, month):
    try:
        months = list(monthly_challenges.keys())
        redirectMonth = months[month-1]
        redirectPath = reverse("month-challenge", args=[redirectMonth])     #builds a path like /challenges/<month>    #for a path with multiple path params, we provide multiple values
        return HttpResponseRedirect(redirectPath)
    except:
        return HttpResponseNotFound('This month is not supported')



RETURNING HTML:
-> Instead of only returning plain text, we can return html tags instead.
-> We do this by using f-strings.
e.g)
text = "lol"
htmlString = f"<h1>{text}</h1>" 

e.g)
def monthly_challenge(request, month):
    try:
        challengeText = monthly_challenges[month]
        responseData = f'<h1 style="color: blue">{challengeText}</h1>'
        return HttpResponse(responseData)
    except:
        return HttpResponseNotFound('This month is not supported')


SPECIFYING ROOT PATHS:
-> To specify root paths just provide an empty string.
e.g)
urlpatterns = [
    path("",views.index),
    path("<int:month>", views.monthly_challenge_by_number),
    path("<str:month>", views.monthly_challenge, name="month-challenge")
]



TEMPLATES:
-> Pretty much EJS from javascript.
-> They are html documents which can handle dynamic content.
-> We create a folder inside the app called 'templates' and another subfolder with the same name as the app.
-> The html files are added into this subfolder.



RETURNING TEMPLATES IN THE HTTP RESPONSE:
-> The way we return html templates in the response is by converting it into a string.
-> We convert it into a string using the render_to_string function from the django.template.loader module.
-> The input parameter which we give to the render_to_string function is the path to the html template from the templates directory.
e.g)
def monthly_challenge(request, month):
    try:
        challengeText = monthly_challenges[month]
        responseData = render_to_string("challenges/challenge.html")
        return HttpResponse(responseData)
    except:
        return HttpResponseNotFound('This month is not supported')

-> This will not immediately work however as the django project will not be able to locate the required templates folder.
-> To fix this, we need to make changes to the settings.py file.
-> Here, to the TEMPLATES list, we add the specific absolute directory to the DIRS sublist.
-> Append the required templates path to the BASE_DIR (path to the django project) variable and put it in the DIRS list.
e.g)
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / "challenges" / "templates"
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
-> Although this works, it is not exactly dynamic as if the name of any folder changes, this will throw an error.
-> But in the case of apps that are not present in our django project, we can only use this way



BETTER WAY TO MAKE THE TEMPLATES FOLDER VISIBLE:
-> Instead of adding the path of the templates folder to the DIRS list, we can notify django about the existence of our app.
-> This would enable django to automatically search all the mentioned apps to find the appropriate templates directory.
-> To do this, in the settings.py file, inside the INSTALLED_APPS list, we can add our app name.
e.g)
INSTALLED_APPS = [
    'challenges',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
-> This works well for apps present within our django project as it makes it dynamic but does not work for directories outside the django project.



NOTE:- It's best practice to create another folder under the templates folder with the same name as the app so that if there are html templates with the same name but in different apps they won't get mixed up with each other.



RETURNING TEMPLATES USING THE RENDER FUNCTION:
-> Instead of using the render_to_string function to convert the html to a string and returning that string as a http response, we can simplify this by directly using the render function.
-> The render function takes two arguments, the first one is the request object and the second is the path to the template.
e.g)
from django.shortcuts import render

def monthly_challenge(request, month):
    try:
        """Directly rendering the html documents using the render function"""
        return render(request, "challenges/challenge.html")
    except:
        return HttpResponseNotFound('This month is not supported')  



DJANGO TEMPLATE LANGUAGE:
-> Similar to EJS.
-> Enhanced html files to create dynamic pages.
-> We pass a dictionary as the third argument to the render function where the keys can be used as variables in the html file.
-> Whenever we want to use these variables in the html file, we must use them in between {{ }}
e.g)
# views.py file
from django.shortcuts import render

def monthly_challenge(request, month):
    try:
        challengeText = monthly_challenges[month]
        """Directly rendering the html documents using the render function"""
        return render(request, "challenges/challenge.html",{
            "text": challengeText,
            "month": month.capitalize()
        })
    except:
        return HttpResponseNotFound('This month is not supported')

#HTML file
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{month}}'s challenge</title>
  </head>
  <body>
    <h1>{{month}}'s challenge</h1>
    <h2>{{text}}</h2>
  </body>
</html>



FILTERS:
-> These are little adjustments/transformations we can apply to the values which we are outputting with interpolation.
-> We can use these to perform adjustments in the template rather than the views.py file before sending it to the template.
e.g)
{{ value|add:"2" }}
-> We always use filters by adding a "|" after the value we want to output followed by the filter we want to apply.
-> For capitalizing the first letter of a word, we can use the "title" filter.
e.g)
<h1>{{ month|title }}'s challenge</h1>
-> Access the following link to learn about more filters:
e.g)
https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference



TAGS:
-> Syntax Feature built into the django template language.
-> Helpful for outputting data in a certain required format.



FOR TAG:
-> Used to iterate through a given list of items.
-> We use {% %} to write out the for tag. The for statement is just python.
-> To specify where we end the for loop, we need to specify a {% endfor %} statement.
-> This is because indentation is not considered in the html template.
e.g)
<body>
    <ul>
        {% for month in months %}
            <li><a href="/challenges/{{ month }}">{{ month|title }}</a></li>
        {% endfor %}
    </ul>
</body> 
-> This example makes use of a hardcoded href path.



URL TAG FOR DYNAMIC URLs:
-> Since the above example makes use of a hardcoded href path and hence is not completely dynamic.
-> To dynamically generate the path we can use the url tag.
-> It is equivalent to the reverse function.
e.g)
<body>
    <ul>
      {% for month in months %}
        <li><a href="{% url "month-challenge" month %}">{{ month|title }}</a></li>
      {% endfor %}
    </ul>
</body>
-> Over here "month-challenge" is the name of the path we are building.
-> And all the variables specified after it are the dynamic segments of the path.
-> We just provide the values/variables seperated by white spaces for the segments.
-> We do not need a closing tag for the URL tag.



WORKING WITH CONDITIONAL CONTENT:
-> We use the "if" tag to work with conditional statements.
-> Also present with the "if" tags are "elif" and "else" tags.
-> We also need a closing tag for the "if" tag.
e.g)
<body>
    <h1>{{ month|title }}'s Challenge</h1>
    {% if text %}
    <h2>{{text}}</h2>
    {% else %}
    <h2>No Challenge has been set for this month</h2>
    {% endif %}
</body>
-> Not closing the if tag throws an error.



TEMPLATE INHERITANCE:
-> We might have a similar template skeleton for all or many web pages in our project.
-> To reduce the amount of work required to be done, we can use template inheritance.
-> We create a templates folder in the root directory and create a base.html or layout.html (name is flexible) in it.
-> We then add the basic structure to this file and specify a {% block <block_name> %} tag for any content which might change from webpage to webpage.
-> The block_name is compulsary.
-> This tag also requires a {% endblock %} closing tag.
-> Anything present in between the opening and closing tags are the default content which will be displayed if no content is passed in from the templates inheriting from this base template.
e.g)
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{% block page_title %}My Challenges{% endblock %}</title>
  </head>
  <body>
    {% block content %}{% endblock %}
  </body>
</html>
-> When we want to inherit this base file in other files, we just use the {% extends "<file_path>" %} tag at the top of the template where we are inheriting.
-> This file_path is a relative path from the current file.
-> We can either provide the relative path or mention the absolute path in the settings.py under the 'DIRS' list.
e.g)
{% extends "../../../templates/base.html" %}

            (OR)

e.g)
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            # BASE_DIR / "challenges" / "templates"
            BASE_DIR / "templates"
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

-> Now in this inherting file, we do not have no specify the basic skeleton but rather only have to specify the blocks in a similar way as before.
e.g)
{% extends "base.html" %}
{% block page_title %} All Challenges {% endblock %}
{% block content %}
    <ul>
    {% for month in months %}
        <li><a href="{% url "month-challenge" month %}">{{ month|title }}</a></li>
    {% endfor %}
    </ul>
{% endblock %}



INCLUDING PARTIAL TEMPLATE SNIPPETS:
-> Same as partials in EJS.
-> In the created app's templates directory, inside the subdirectory with the same name as the app, create a folder called partials.
-> This folder houses parts of the code which are to be re-used in multiple files.
-> To now include these reusable pieces of code, we use the {% include <file_path> %} tag.
-> The file_path is a relative path from the cwd.
-> The file_path can also be a path from the 'templates' directory of the specified app as long as the app is recognisable by django.
-> We have access to the variables sent to templates which include partial files from the partial files themselves.  
e.g)
{% block content %}
    <!-- {% include "challenges/partials/header.html" %} -->
    {% include "./partials/header.html" %}
    <h1>{{ month|title }}'s Challenge</h1>
    {% if text %}
	<h2>{{text}}</h2>
    {% else %}
	<h2>No Challenge has been set for this month</h2>
    {% endif %} 
{% endblock %}

-> We can also pass in specific values depending on which webpage we're on using the "with" keyword.
-> These specific values can be used in the partial files and vary according to the value passed while including them.
e.g)
{% include "./partials/header.html" with active_page="challenge" %}
-> We can now use this 'active_page' variable in the partials file however we want.



NOTES: 
-> We cannot access dictionary items in the DTL using {{ dictionary['key'] }}, we'll have to access it using {{ dictionary.key }} instead.
-> We also cannot call functions as we do in python {{ function_name() }}, we'll have to do {{ function_name }} instead.



404 TEMPLATES:
-> We usually create a 404 template in the templates directory present in the root directory of the project.
-> We cannot use the render function directly as it always returns a success response.
-> Therefore we use the HttpResponseNotFound function instead, along with the render_to_string function to return a 404 template.
e.g)
def monthly_challenge(request, month):
    try:
        challengeText = monthly_challenges[month]
        """Directly rendering the html documents using the render function"""
        return render(request, "challenges/challenge.html",{
            "text": challengeText,
            "month": month
        })
    except:
        response_data = render_to_string("404.html")
        return HttpResponseNotFound(response_data)

-> Another method we can use is the inbuilt Http404 function.
-> This function raises a 404 error and searches for a file named '404.html' to display.
-> However, this will not work in developement as DEBUG must be set to False in the settings.py file which we usually do while deploying.
-> But if we set this to False during developement, the server stops working.
e.g)
def monthly_challenge(request, month):
    try:
        challengeText = monthly_challenges[month]
        """Directly rendering the html documents using the render function"""
        return render(request, "challenges/challenge.html",{
            "text": challengeText,
            "month": month
        })
    except:
        raise Http404()



ADDING STATIC FILES:
-> To add static files for a specific app, we create a 'static' folder right next to the templates directory which can contain our javascript logic and css styling.
-> Inside this 'static' folder, we add another folder which has the same name as the app it's being created in.
-> Now to make sure the changes work, check settings.py to see if 'django.contrib.staticfiles' is present in the INSTALLED_APPS list.
e.g)
INSTALLED_APPS = [
    'challenges',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

-> To load the built in plugins to use static files in our templates, we use the {% load static %} tag.
-> We need to use the <link rel="stylesheet" href=""> tag in our template to specify which static file we want to use  (specify path in href).
-> We use thd block tag in the base template so that the static files can vary from template to template.
e.g)
{% extends "base.html" %}

{% block page_title %} All Challenges {% endblock %}

{% block links %} <link rel="stylesheet" href="{% static "challenges/challenges.css" %}"> {% endblock %}

{% block content %}
  <ul>
    {% for month in months %}
      <li><a href="{% url "month-challenge" month %}">{{ month|title }}</a></li>
    {% endfor %}
  </ul>
{% endblock %}

-> Over here we use the {% static "<path>" %} tag to build us a path to the required static file.
-> This static tag can only be used after loading it using the {% load static %} tag.
-> If the applied changes(css styles / js logic) do not show up at first, just restart the developement server.



ADDING GLOBAL STATIC FILES:
-> To do this, create a 'static' folder in the root directory.
-> Now add your styles here.
-> This can be used throughout the entire project.
-> We use the <link rel="stylesheet" href=""> tag directly in the base template instead of using block tags since we want to make the static files global.
e.g)
{% load static %}

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{% block page_title %}My Challenges{% endblock %}</title>
    <link rel="stylesheet" href="{% static "styles.css" %}" /> {% block links %}
    {% endblock %}
  </head>
  <body>
    {% block content %}{% endblock %}
  </body>
</html>

-> However, the problem with this is that django only looks for static files in the apps and not on the global level.
-> To make this gloabal level 'static' directory visible to django, we add a 'STATICFILES_DIRS' list to the settings.py file.
-> This adds directories which django should while checking for static files.



BUILDING STATIC URLs WITH VARIABLES:
-> To build static URLs with variables, i.e, part of the path is represented as a variable in templates.
-> We cannot do this how we normally do in python, i.e, using the '+' operator.
-> Instead, we must use the add filter.
e.g)
{% static "my_path/to/"|add:the_file %}



SLUGS:
-> Slugs are basically unique identifiers to uniquely identify different items of a website.
-> Django comes with a slug checker which checks if the slug has only character, numbers and '-'. Any other special characters would result in an error.
e.g)
urlpatterns = [
    path("", views.index),
    path("posts", views.posts),
    path("posts/<slug:slug>", views.specific_post)
]



ADDING IMAGES AS STATIC FILES:
-> Same as working with other static files.
-> Create a seperate subdirectory in the 'static' dircetory called images, and add all images needed in that app into that images folder.
-> We build a path to the needed resource the same way we would for other static files, i.e, using the static tag.



THE LINEBREAKS FILTER:
-> If we want to output string content exactly as it is (with linebreaks) using interpolation, we use the linebreaks filter.
-> This outputs the content along with the appropriate linebreaks.
e.g)
<main>
    {{project.content|linebreaks}}
</main>



THE DATE FILTER:
-> This can be used to output date date in a specific format.
e.g)
<div>
    Last Updated on <time>{{project.date|date:"d M Y"}}</time>
</div>



SQL DATABASES:
-> Store data in tables
-> Have same schema which every row must follow.
-> MySQL, PostgreSQL, SQLite


NoSQL Databases:
-> Store data in documents (looks like dictionaries)
-> No clear schema
-> MongoDB, Cassandra



NOTE: We do not have to write SQL queries to interact with the database as while using django, we use data models to interact with the database.



WORKING WITH DJANGO MODELS:
-> We define our data entities in the models.py file of the specific app.
-> These entities are basically blueprints for the data objects that we will work with.
-> To start out, we create a class which extends the 'models.Model' class.
-> In this class we shall define the structure of a database entity.
-> The table being created will be plural of the class name.
-> We define the type of data each field can accept.
-> Refer here for more information:
e.g)
https://docs.djangoproject.com/en/5.0/ref/models/fields/

-> We use the models.CharField() type to specify that we want to store strings which are small to medium size.
-> We need to add one argument to the constructor, i.e., the max_length argument.
e.g)
from django.db import models
class Book(models.Model):
    title = models.CharField(max_length=50)

-> We use the models.IntergerField() type to store values which are strictly integers without decimal points.
e.g)
from django.db import models
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField()

-> We use the models.TextField() type to specify that we want to store strings which are large sized.
-> A max_length parameter is not compulsary while using this.
e.g)
from django.db import models
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField()
    content = models.TextField()

-> We use the models.EmailField() type to specify that we want to store a string which must be of an email format.
e.g)
from django.db import models
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField()
    content = models.TextField()
    email_address = models.EmailField()

-> An id column which has an auto-incrementing number is automatically created whenever data is added.
-> If we want to set it ourselves, we can using the 'id = models.AutoField()', but we don't need to.
-> This is needed as an unique identifier.



MIGRATIONS:
-> We need to make django aware of the newly created class so that it can create a table and perform data operations on it.
-> We make it aware by registering the app in the settings.py file.
-> We do this in two steps.
-> The first step is similar to how we made django aware of apps for templates.
e.g)
INSTALLED_APPS = [
    'book_outlet',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

-> Now we need to tell django that it should reach out to the db.sqlite3 file and create the necessary tables.
-> We do this by using migrations.
-> The migrations feature basically defines steps for django to execute. These steps help to touch the database and manipulate it.
-> Therefore when we add/update models in the 'models.py' file, we need to make sure we create migrations for django to execute (instructions on how to update database)

-> To create migrations, we first navigate into the overall project folder and run:
e.g)
python manage.py makemigrations

-> This populates the migrations folder of all the apps where migrations are needed.
-> Now to execute the migrations files which have not been executed yet, we need to run:
e.g)
python manage.py migrate



OPENING A TERMINAL TO INTERACT WITH THE DATABASE:
-> To open an interactive python interpreter/terminal, do: 
e.g)
python manage.py shell



INSERTING DATA:
-> We use the specific class(of the table) we created to add data into the database.
-> Each entry into the table will be an instantiation of the class.
-> We must instantiate these entries using keyword arguments.
e.g)
>> from book_outlet.models import Book
>> harry_potter = Book(title="Harry Potter 1", rating = 5)

-> However, this does not do anything with the database yet.
-> To insert this entry into the database, we use the .save() method.
e.g)
>> harry_potter.save()



GETTING ALL ENTRIES:
-> To get all entries in a table, we use the .objects.all() method.
e.g)
>> Book.objects.all()
-> However, the entries normally returned by this are all cryptic.



MIN AND MAX VALUE VALIDATORS:
-> To add min and max value validators, we need to import MinValueValidator and MaxValueValidator from django.core.validators
e.g)
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])



MIN AND MAX LENGTH VALIDATORS:
-> We can also work with min and max length validators for string data.
e.g)
from django.db import models
from django.core.validators import MinLengthValidator, MaxLengthValidator
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField()
    content = models.TextField(validators=[MinLengthValidator(10), MaxLengthValidator(1000)])



UPDATING MODELS AND MIGRATIONS:
-> We can add methods in our blueprint class which we define in the models.py file. (for data specific business logic)
-> We can also add utility methods and override built in existing methods.

-> One useful built in utility method which we can override is the __str__ method.
-> This method exists in every class in python (not django or model specific).
-> When we override this class, we can specify how instances of this class should be outputted in the terminal
e.g)
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField()
    def __str__(self):
        return f"{self.title} ({self.rating})"

-> Everytime we update a model schema, we also need to correspondingly update the database.
-> To do this, we just simply run:
e.g)
python manage.py makemigrations
-> If we do not provide a default value for the new fields, we will recieve a prompt asking how we want to fill these fields.
-> To prevent this, in the new field which we are creating, we add a parameter 'null=True' or we can also provide 'default=<value>'.
-> We can also add the parameter 'blank=True' which basically says that the value can be empty (different from null).
-> Now if we run the makemigrations command, we won't recieve a prompt.
-> After running the command, a new migrations file is created. Django creates new files so that we can rollback migrations if needed.
-> Now we run the command
e.g)
python manage.py migrate

-> To access any particular field of a class instance in the database from the terminal, we can simply use the dot notation
e.g)
>> Book.objects.all()[1].is_bestselling
False



BLANK vs NULL:
-> The blank type specifies that a value is not needed while getting information from a form.
-> The null type specifies the value (null) that must added into a database in case a field is not provided.



UPDATING DATA:
-> One way to access each individual item(model class instantiation), is
e.g)
>> harry_potter = Book.objects.all()[0] 
-> Of course this is not completely optimal.

-> To update this value, we just need to do
e.g)
>> harry_potter.author = "J.K. Rowling"
>> harry_potter.is_bestselling = True
-> However, this only updates the value in the python memory.

-> To update this entry in the database, we just need to run
e.g)
>> harry_potter.save()



DELETING DATA:
-> We delete data by doing
e.g)
>> harry_potter = Book.objects.all()[0]
>> harry_potter.delete()

-> This returns us a tuple containing information on how many items were deleted and for which models the deletion were for.
e.g)
(1, {'book_outlet.Book': 1})



USING CREATE INSTEAD OF SAVE:
-> Instead of making a class instance for a model and then running the save() method on it to add that instance into the database, we can just use the create method
-> This skips the step of having to save() the instance into the database by doing it automatically.
-> This function also returns us the instance just created.
e.g)
>> Book.objects.create(title="My Story", author="Sudeev", rating = 5, is_bestselling = True)



QUERYING & FILTERING DATA:
-> To find certain instances of a model from a database, we can use the get() method.
e.g)
>> Book.objects.get(id=3)
>> Book.objects.get(title="My Story")

-> However, the get() method only gets one entry from the database.
-> If we query something that has more than one entry, it will throw an error

-> To get multiple entries from the database, we use the filter() method.
e.g)
>> Book.objects.filter(is_bestselling = True)

-> However, if we try filter(rating<3), this will result in an error as it is invalid python syntax(cannot pass expression as an argument).
-> TO overcome this, django provides us with field lookups which we append to field names to help filter out items based on other ways(inequality and startswith)
e.g)
>> Book.objects.filter(rating__lt=3)
>> Book.objects.filter(rating__lte=3)
>> Book.objects.filter(rating__gte=3)
>> Book.objects.filter(rating__gt=3)
-> To find items with a certain substring, we do
e.g)
>> Book.objects.filter(rating__lt=3, title_contains="Story")
-> By default __contains is case sensitive. To perform non-case-sensitive filtering , we use __icontains. __contains by default does not perform case sensitive searching for SQLite though.

-> To view more such field lookups, visit the following documentation
e.g)
https://docs.djangoproject.com/en/5.0/topics/db/queries/



OR CONDITIONS:
-> Till now, all filtering which we perform are 'and' conditions.
e.g)
>> Book.objects.filter(rating__lt=3, title_contains="Story")

-> To perform 'or' conditions, we first need to import Q
e.g)
from django.db.models import Q

-> We wrap each individual expressions within this Q() function and seperate it using the '|'.
-> Anything seperated between the '|' will have the 'or' condition applied on them.
e.g)
>> Book.objects.filter(Q(rating__lt=3) | Q(is_bestselling=True))

-> We can also perform 'and' conditions using the Q() function.
-> We do this by seperating the expressions with a ','
e.g)
>> Book.objects.filter(Q(rating__lt=3) | Q(is_bestselling=True), Q(author = "J.K. Rowling"))
-> We can also write the above query where the 'and' condition is not wrapped in the Q() function granted that the 'and' condition shows up at the end(after all 'or' conditions)
e.g)
>> Book.objects.filter(Q(rating__lt=3) | Q(is_bestselling=True), author = "J.K. Rowling")



QUERY PERFORMANCE:
-> When we run a query like, bestsellers = Book.objects.filter(is_bestselling=True), the database is not immediately accessed.
-> The only thing stored in bestsellers is the query definition(query set), but not the result of the query.
-> This is done to improve query performance. We can also chain on more filter calls without accessing the database directly.
e.g)
>> amazing_bestsellers = bestsellers.filter(rating__gt=4)
-> Django will only access the database when we need to use the information stored in it.
e.g)
>> print(amazing_bestsellers)

-> Django also caches the results until the values are changed in the database so that less database accesses have to be made.
-> Chained filter calls refer to cached data to get the information it needs, thereby reducing the number of database accesses even more.
NOTE: Not storing a value in a variable will not result in cached values.



BULK OPERATIONS:
-> To delete multiple model instances at once, we first filter out the query set we want to delete and run the delete() function on them.
e.g)
>> Book.objects.filter(rating=4).delete()
-> When django deletes a model instance, it emulates the behaviour of the SQL constraint 'ON DELETE CASCADE'

-> To update multiple model instances at once, we use the bulk_update(objs, fields, batch_size=None) function.
-> The fields parameter is a list of all the fields which should be updated.
e.g)
>> objs = [
...    Entry.objects.create(headline='Entry 1'),
...    Entry.objects.create(headline='Entry 2'),
... ]
>> objs[0].headline = 'This is entry 1'
>> objs[1].headline = 'This is entry 2'
>> Entry.objects.bulk_update(objs, ['headline'])

-> To create multiple model instances in bulk, we use the bulk_create() function.
-> This method inserts a list of objects into the database in an efficient manner.
e.g)
>> Entry.objects.bulk_create([
...     Entry(headline='This is a test'),
...     Entry(headline='This is only a test'),
... ])



NOTE: While querying with the get(id=<id>) method where the field is the id, we can also write this as .get(pk=<id>)



QUERYING IN FILES:
-> Done the same way as done in the shell
e.g)
def book_detail(request, id):
    try:
        book = Book.objects.get(pk=id)
    except:
        raise Http404()
    return render(request, "book_outlet/book_detail.html", {
        "title": book.title,
        "author": book.author,
        "rating": book.rating,
        "is_bestselling": book.is_bestselling
    })

-> In the above code, if we do not succeed in retrieving the items from the database(any error occurs), we raise a Http404 error which displays the 404.html template.
-> There is a function for this whole functionality already however. 
e.g)
from django.shortcuts import render, get_object_or_404
def book_detail(request, id):
    book = get_object_or_404(Book, pk=id)
    return render(request, "book_outlet/book_detail.html", {
        "title": book.title,
        "author": book.author,
        "rating": book.rating,
        "is_bestselling": book.is_bestselling
    })

-> The above code also has the same functionality.



BUILDING DYNAMIC URLS USING MODELS:
-> We can build dynamic urls using the {% url %} tag in DTL.
-> However, another way to do this is to override the 'get_absolute_url(self)' function in the specific model's class.
e.g)
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    author = models.CharField(null=True, max_length=100)
    is_bestselling = models.BooleanField(default=False)
    def get_absolute_url(self):
        return reverse("book-details-page", args=[self.id])   
    def __str__(self):
        return f"{self.title} ({self.rating})"

e.g)
{% extends "book_outlet/base.html" %} {% block title %} All Books {% endblock %}
{% block content %}
<ul>
  {% for book in books %}
  {% comment %} <li><a href="{% url "book-details-page" book.id %}">{{ book.title }}</a> (Rating: {{ book.rating }})</li> {% endcomment %}
  <li><a href="{{ book.get_absolute_url }}">{{ book.title }}</a> (Rating: {{ book.rating }})</li>
  {% endfor %}
</ul>
{% endblock %}



MAKING CUSTOM SLUGS:
-> We have used the default 'id' fields as unique identifiers in our routes so far.
-> If we wish to add unique slug values as the identifiers, we can do so by the following steps
-> The first step is to create a slug field in the model class with the field type as models.SlugField()
e.g)
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    author = models.CharField(null=True, max_length=100)
    is_bestselling = models.BooleanField(default=False)
    slug = models.SlugField(default="", null=False)

-> Now to make sure that every slug does not have a value of "", we must override the built in save model class method.
-> At the end of this overridden save method, we must also call the default inbuilt save method. 
-> What we are doing right now, is just adding additional code which will be run when the save method is called. We do not want to get rid of the original save function.
e.g)
def save(self):
    .......
    super().save(*args, **kwargs)

-> We then import slugify from django.utils.text
-> This function helps us convert a certain string/text into a slug automatically.
e.g)
from django.utils.text import slugify
class Book(models.Model):
    slug = models.SlugField(default="", null=False)
    def save(self, *args, **kwargs):
        self.slug = slugify(self.title)
        super().save(*args, **kwargs)

-> If the data field is just newly added, the old entries' new field values must be populated.
-> In the above mentioned case, we can do this by just saving each item back into the database.
e.g)
>> Book.objects.get(title="Despicable Me").save()

-> Additionally if we want to make a slug or any field unique, we can set an extra parameter 'unique=True'.
e.g)
class Post(models.Model):
    title = models.CharField(max_length=150)
    excerpt = models.CharField(max_length=200)
    slug = models.SlugField(unique=True, db_index=True)

-> We do not need to set the 'db_index' parameter as True because for a SlugField, the db_index parameter is True by default.
-> We do not need the 'db_index' parameter also because we have already set 'unique=True'. Setting 'unique=True', automatically creates an index.



IMPROVING PERFORMANCE BY ADDING DATABASE INDEXES:
-> If we have a field which we use very often (e.g. the slug field which is used everytime we view a specific book or database item), we can set it as a database index to increase performance.
-> We can do this by adding the parameter db_index=True for the field in the model class.
-> This makes searches for the specific field more efficient.
-> We should only set a few fields as indexes as setting all/many fields can lead to a decrease in performance.
e.g)
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    author = models.CharField(null=True, max_length=100)
    is_bestselling = models.BooleanField(default=False)
    slug = models.SlugField(default="", null=False, db_index=True)


AGGREGATION AND ORDERING:
-> Helps us get the count, average, max, min, etc. of a provided query set.
-> To find the count of all items in a query set, we use the .count() function
e.g)
def index(request):
    books = Book.objects.all()
    num_books = books.count()
-> num_books now holds the number of books in the 'books' query set.

-> To find the average, min, max, etc. we use the .aggregate() function along with a method imported from django.db.models
-> We use the Avg, Min, Max, etc. functions inside the .aggregate() function.
-> The parameter to the Avg, Min, Max, etc. functions is the field to which we want to apply the specific aggregation on.
e.g)
from django.db.models import Avg, Max, Min
def index(request):
    books = Book.objects.all()
    num_books = books.count()
    avg_rating = books.aggregate(Avg("rating"))



ORDERING DATA:
-> We use the .order_by() function on a query set to sort the query set in order of a specified field.
-> We can also order by multiple fields if we want to.
e.g)
def index(request):
    books = Book.objects.all().order_by("title")

-> If we want to sort a query set in descending order of a specified field, we just add a '-' before the field we want to order.
e.g)
def index(request):
    books = Book.objects.all().order_by("-title")

-> If we want to sort the fields in order of more than one field, we can specify the multiple fields seperated by ',' to the .order_by() function.
e.g)
def index(request):
    books = Book.objects.all().order_by("rating", "-title")



DJANGO ADMIN FEATURE:
-> Django has a built in administration user interface which we can use to administer our data.
-> Meant to be used by the developer adding items onto the database. Not to be used for users placing orders, etc.
-> To access this user interface, we just visit "http://localhost:800/admin/"
-> To login, we need to create a superuser. We do this by doing
e.g)
python manage.py createsuperuser
-> After entering the necessary details, we should be able to login.



ADDING MODELS TO ADMIN AREA:
-> Not all of our models have to be managed by django admin.
-> User generated data is usually not managed by django admin.
-> Therefore we need to make django admin aware of which data it should manage.
-> To do this we use the admin.py file as shown below
e.g)
from django.contrib import admin
from .models import Book
# Register your models here
admin.site.register(Book)

-> This makes the Book model visible in django admin.



CONFIGURING MODEL FIELDS:
-> In django admin, if we automatically set the value for a field on save(or anything else) in the model class, we must provide an option to create an item without the corresponding field being required.
-> To do this, we set 'blank=True' in the model class field.
-> Doing this makes sure that the same field in django admin will not be required before creating an instance of that model class.

-> Another way to do this would be to set 'editable=False'
-> This would make it so that the field will not show up in django admin
e.g)
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    author = models.CharField(null=True, max_length=100)
    is_bestselling = models.BooleanField(default=False)
    slug = models.SlugField(default="", blank=True, editable=False, null=False, db_index=True)   
    def save(self, *args, **kwargs):
        self.slug = slugify(self.title)
        super().save(*args, **kwargs)



CONFIGURING MODEL FIELDS IN MORE DETAIL:
-> To configure model fields in more detail, we can create a class in the admin.py file.
-> The name of this class is usually '<ModelName>Admin' and it extends 'admin.ModelAdmin'
-> To make django admin aware of this class, we give this class as a second parameter to 'admin.site.register'

-> If we want to configure any of the fields as read only, we set a tuple called 'readonly_fields' with all the fields which we wish to set as read only.
e.g)
class BookAdmin(admin.ModelAdmin):
    readonly_fields = ("slug",)

-> If we already want to display a value for a field beforehand, we set a dictionary called 'prepopulated_fields' where the keys are the fields which we want to prepopulate and the values are tuples of fields from which we are prepopulating.
-> A field cannot be set to both readonly_fields and prepopulated_fields at the same time.
e.g)
class BookAdmin(admin.ModelAdmin):
    # readonly_fields = ("slug",)
    prepopulated_fields = {"slug": ("title","rating")}
-> In the above code, title, rating and slug are all of different types but django auto converts title and rating to slug type using slugify under the hood.

-> The django admin form has built in validations to make sure the data being entered is of the right type.



SETTING FILTERS:
-> We can filter all items when they are being displayed by certain fields.
-> To do this all we need to do is add a 'list_filter' property to the class in the admin.py file.
-> This 'list_filter' property is a tuple containing the fields by which we want to filter.
e.g)
class BookAdmin(admin.ModelAdmin):
    prepopulated_fields = {"slug": ("title","rating")}
    list_filter = ("rating", "author")



DISPLAYING ONLY CERTAIN MODEL FIELDS:
-> To display only certain model fields in the django admin area, we use the 'list_display' property.
-> The 'list_display' property is a tuple containing the model fields which we want to display on the django admin area.
e.g)
class BookAdmin(admin.ModelAdmin):
    prepopulated_fields = {"slug": ("title","rating")}
    list_filter = ("rating", "author")
    list_display = ("title", "author")



MORE CONFIG OPTIONS:
-> For more information on configuring model fields, visit the below link
e.g)
https://docs.djangoproject.com/en/5.0/ref/contrib/admin/



UNDERSTANDING RELATIONSHIP TYPES:
-> Data is often connected.
-> The ways in which data can be connected differs from model to model.
-> One-to-many, one-to-one, many-to-many relationships are a few examples.



CONNECTING TWO MODELS (ONE-TO-MANY):
-> To connect two models, we make use of 'models.ForeignKey(<ModelName>)'
-> This creates a pointer from one table entry to another table entry in the database.
e.g)
class Author(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
class Book(models.Model):
    author = models.ForeignKey(Author)

-> To set an on-delete cascade, we simply add
e.g)
class Book(models.Model):
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

-> To set all values to null after deletion, we simply add
e.g)
class Book(models.Model):
    author = models.ForeignKey(Author, on_delete=models.SET_NULL)

-> To prevent the deletion of the referenced object if there are any objects referring to it, we simply add
e.g)
class Book(models.Model):
    author = models.ForeignKey(Author, on_delete=models.PROTECT)

-> We need to run makemigrations and migrate anytime we make changes to the models.py file.
-> Set null=True on the newly added fields so that makemigrations does not result in a warning/error.
-> However since the author value previously had string values which does not match the newly set foreign key, we need to cleanse the database where data insertion causes error.
-> Now we have successfully updated schema changes to the database.



ADDING DATA FOR MODELS WITH RELATIONSHIPS:
-> When creating a model instance with a foreign key, we need to provide the query instance of the referred instance in the foreign key field.
-> We can get this query instance by either using the .get() method if the instance is already created or the .create() method if the query instance is not already created.
e.g)
>> jkrowling = Author(first_name="J.K.", last_name="Rowling")     
>> jkrowling.save()
>> hp1 = Book(title="Harry Potter 1", rating=5, is_bestselling=True, author=jkrowling)



CROSS MODEL QUERIES:
-> To access the sub-fields of a foreign key, we use '__'
e.g)
>> books_by_rowling = Book.objects.filter(author__last_name="Rowling")
>> books_by_rowling = Book.objects.filter(author__last_name__contains="wling")

-> To do the inverse of this, i.e. access the referer query set from the referred model, we first get the referred item from the database.
-> We then use '.<referer_model_name_in_lower_case>_set' property (equivalent to '.objects')
-> Now, if we chain .all() on the above query, we get the reverse query set.
e.g)
>> jkrowling = Author.objects.get(first_name = "J.K.") 
>> jkrowling.book_set.all()
<QuerySet [<Book: Harry Potter 1 (5)>]>

-> In the above example, if we do not want to use the name book_set and we want to use a custom name, we can do this by setting a 'related_name' parameter in the foreign key.
e.g)
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    author = models.ForeignKey(Author, on_delete=models.CASCADE, null=True, related_name="books")
-> Now we can reverse query by
e.g)
>> jkrowling = Author.objects.get(first_name = "J.K.") 
>> jkrowling.books.all()
<QuerySet [<Book: Harry Potter 1 (5)>]>



ADDING A ONE-TO-ONE RELATIONSHIP:
-> Setting up a one-to-one relationship is the same as setting up a one-to-many relationship except that instead of 'models.ForeignKey()', we use 'models.OneToOneField()'.
e.g)
class Address(models.Model):
    street = models.CharField(max_length=80)
    postal_code = models.CharField(max_length=5)
    city = models.CharField(max_length=50)
class Author(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    address = models.OneToOneField(Address, on_delete=models.CASCADE)

-> For one-to-one relationships, we do not need to set the 'related_name' parameter to anything as it can be accessed by the referred model by just '<referer_model_name_in_lower_case>'.
-> Run makemigrations and migrate and set the null=True wherever required.



REPRESENTING THE MODEL NAME CORRECTLY IN ADMIN AREA:
-> Certain model names can be represented incorrectly in the admin area. For example, 'Address' will be represented as 'Addresss'.
-> To configure this the way we want to, we need to add a Meta subclass to our model class in the models.py file.
-> We now have to override the 'verbose_name_plural' property to change how the model will be represented in the admin area.
-> We can also change how the singular form of the model will be represented using the 'verbose_name' property.
e.g)
class Address(models.Model):
    street = models.CharField(max_length=80)
    postal_code = models.CharField(max_length=5)
    city = models.CharField(max_length=50)
    def __str__(self):
        return f"{self.street}, {self.city} - {self.postal_code}"  
    class Meta:
        # verbose_name = "Address"
        verbose_name_plural = "Address Entries"



NOTE: No two instances from the referrer model class can point to the same model instance of the referred class in a one-to-one relationship. Trying to do this will result in an error. 



MANY-TO-MANY RELATIONSHIPS:
-> Setting up a many-to-many relationship is the same as the other two relationship types except the only thing we change here is 'models.ManyToManyField()'
-> For many-to-many relationships, we do not set the on_delete parameter.
e.g)
class Country(models.Model):
    name = models.CharField(max_length=80)
    code = models.CharField(max_length=2)
class Book(models.Model):
    title = models.CharField(max_length=50)
    rating = models.IntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    author = models.ForeignKey(Author, on_delete=models.CASCADE, null=True, related_name="books")
    is_bestselling = models.BooleanField(default=False)
    slug = models.SlugField(default="", blank=True, null=False, db_index=True)
    published_countries = models.ManyToManyField(Country)

-> Run makemigrations and migrate and set null=True if error shows up.



QUERYING MANY-TO-MANY RELATIONSHIPS:
-> Querying many to many relationships are almost completely the same except the only thing which we change is how we add instances in many-to-many fields.
-> Instead of using '<Referer_model_name>.field = <Referred_model_instance>', we use the .add() method.
-> We do this because in many-to-many relationships, the referer field is actually a list containing all the refered model instances.
e.g)
>> germany = Country.objects.create(name="Germany", code="DE")
>> mys = Book.objects.all()[1]
>> mys.published_countries.add(germany)
>> mys.published_countries.filter(code="DE") 
<QuerySet [<Country: Germany, DE>]>

-> If we want to access the referer model set from the referred model, we can use 'book_set'.
-> We can also add a 'related_name' parameter as seen before to use the 'related_name' value instead of 'book_set'.
e.g)
>> c1 = Country.objects.all()[0]
>> c1.book_set.all()
<QuerySet [<Book: Harry Potter 2 (5)>]>



CIRCULAR AND LAZY RELATIONS:
-> Sometimes, you might have two models that depend on each other - i.e. you end up with a circular relationship.
-> Or you have a model that has a relation with itself.
-> Or you have a model that should have a relation with some built-in model (i.e. built into Django) or a model defined in another application.
-> Here is how to tackle all these issues

-> For cases where we have multiple relationships between the same two models, we might need to define them in both models. By using the model name as a string instead of a direct reference, Django is able to resolve such dependencies.
e.g)
class Product(models.Model):
  # ... other fields ...
  last_buyer = models.ForeignKey('User')
class User(models.Model):
  # ... other fields ...
  created_products = models.ManyToManyField('Product')

-> For cases where a model has relations with itself, the special self keyword (used as a string value) tells Django that it should form a relationship with (other) instances of the same model.
e.g)
class User(models.Model):
  # ... other fields ...
  friends = models.ManyToManyField('self')

-> For relationships with other apps and their models (built-in or custom apps), we can reference them by using the app name and then the name of the model inside the app.
e.g)
class Review(models.Model):
  # ... other fields ...
  product = models.ForeignKey('store.Product') # '<appname>.<modelname>'



DJANGO PERFORMANCE NOTE:
-> When we write a python query like this
e.g)
latest_posts = Post.objects.all().order_by("-date")[:3]
-> Django does not retrieve all posts from the database and take the first 3 posts from it.
-> Django is smart enough to construct the SQL query in such a way that it only retrieves the 3 needed posts from the database. 
NOTE: Django does not allow negative indexing in the above example code.



FORMS:
-> Form tags can be used to submit a request to a specified API.
-> Any button present within the form tags will be used to submit a request.
-> The various input tags data will be set as the query string.
-> If we want to set a specific button in form tags to not automatically submit a request, we can set it's 'type' property to 'button'.
e.g)
<form>
    <button type='button'>Send</button>
</form>
-> The above example will not automatically submit a request.

-> This API is a GET request by default, unless explicitly specified using the 'method' property.
e.g)
<form method="POST">
    <button>Send</button>
</form>
-> The POST request contains the request data in it's body instead of the query string.



CSRF PROTECTION:
-> Cross Site Request Forgery.
-> We prevent this using CSRF tokens.
-> These tokens (dynamically generated) are sent from the form to the backend to make sure the request is coming from a trusted and not scam source.
-> Only the official server knows how to build that token and how a valid token should look like.
-> We only accept requests if it has a valid CSFR token.
-> To insert a token into our form, we use the 'csrf_token' tag.
e.g)
<body>
    <form method="POST">
      {% csrf_token %}
      <label for="username">Your name</label>
      <input id="username" name="username" type="text" />
      <button>Send</button>
    </form>
</body>

-> Django automatically generates a token after we add the 'csrf_token' tag.
NOTE: We need this everytime, we use a POST request.



HANDLING FORM SUBMISSION AND EXTRACTING DATA:
-> To send a request to a specific URL, we do
e.g)
<form action="/user-review" method="POST">
    {% csrf_token %}
    <label for="username">Your name</label>
    <input id="username" name="username" type="text" />
    <button>Send</button>
</form>

-> The "/user-review" adds onto the domain name, for example "localhost:8000"

-> Since we might want to have different view functionalities for different request types (get, post, etc.), we access the 'request.method' attribute and write 'if-else' statements for different request types.
-> If it is a post method, we can access the request body using the 'request.POST' dictionary.
-> This dictionary contains keys which are the names of the input fields and the values are the corresponding values entered.
e.g)
def review(request):
    if request.method == 'POST':
        entered_username = request.POST['username']
        print(entered_username)
        
    return render(request, "reviews/review.html")

-> Usually for POST requests, we do not return templates, but we rather redirect to a different URL with a get request and the different URL returns a template.
-> This is done so that if a user reloads a page while submitting, two post requests are not sent at the same time.
-> We return a redirect as follows,
e.g)
from django.http import HttpResponseRedirect
def review(request):
    if request.method == 'POST':
        entered_username = request.POST['username']
        print(entered_username)
        return HttpResponseRedirect("/thank-you")        
    return render(request, "reviews/review.html")
def thank_you(request):
    return render(request, "reviews/thank_you.html")



FORM VALIDATIONS WITH THE DJANGO FORM CLASS:
-> Manual form validations with vanilla python would result in a lot of work and code.
-> To reduce this work and code, we can use the Django Form Class.

-> To get started, we first create a 'forms.py' file in our created app.
-> This file contains a class which defines the shape of a form with the different input fields it can offer.
-> This class does not have any impact on the database.
e.g)
from django import forms
class ReviewForm(forms.Form):
    user_name = forms.CharField()

-> This class which we create can be used as the form in the html template.
We do this as follows,
e.g)
from django.http import HttpResponseRedirect
from django.shortcuts import render
from .forms import ReviewForm
def review(request):
    form = ReviewForm()       
    return render(request, "reviews/review.html", {
        "form": form
    })
def thank_you(request):
    return render(request, "reviews/thank_you.html")

-> Now we display the form in the template in the following manner,
e.g)
<form action="/" method="POST">
    {% csrf_token %} 
    {{ form }}
    <button>Send</button>
</form>

-> This will allow django to automatically generate HTML content on it's own.
-> The input fields are required by default.

-> To use django for form validations, we do
e.g)
def review(request):
    if request.method == 'POST':
        form = ReviewForm(request.POST)
        if form.is_valid():
            print(form.cleaned_data)
            return HttpResponseRedirect("/thank-you")

    form = ReviewForm()
        
    return render(request, "reviews/review.html", {
        "form": form
    })

-> The '.is_valid()' function returns a boolean value.
-> The 'form.cleaned_data' is pretty much a dictionary containing the key value pairs to access the contents of a form.



DISPLAYING FORM ERROR MESSAGES:
-> To display error messages in django in case the form is not valid, we simply display the invlaid form class instantiation
e.g)
def review(request):
    if request.method == 'POST':
        form = ReviewForm(request.POST)
        if form.is_valid():
            print(form.cleaned_data)
            return HttpResponseRedirect("/thank-you")
    else:
        form = ReviewForm()    
    return render(request, "reviews/review.html", {
        "form": form
    })

-> We can fix up the styling portion of these error messages later.
-> The error messages shown are in an unordered list present above the form elements.
-> In the case of errors arising, the previously entered values for the fields will still be present and will not be disposed off.



CUSTOMIZING FORM CONTROLS:
-> By default, label names are the key names provided in the classes of the 'forms.py' file where the first letter is uppercased and any underscores in between are removed and turned into whitespaces.
-> To set a custom label for an input field, we can use the 'label' parameter along with the label name as a string.
e.g)
from django import forms
class ReviewForm(forms.Form):
    user_name = forms.CharField(label="Your name")

-> To set a max length validator, we add the 'max_length' parameter
e.g)
class ReviewForm(forms.Form):
    user_name = forms.CharField(label="Your name", max_length=100)

-> We can also set our own custom error messages using the 'error_messages' parameter
-> This 'error_messages' parameter is a dictionary where the key names are the validator identifiers known by django and the values are the custom error messages. 
e.g)
class ReviewForm(forms.Form):
    user_name = forms.CharField(label="Your name", max_length=100, error_messages={
        "required": "Your name must not be empty!",
        "max_length": "Please enter a shorter name!"
    })

-> If we want to set a field as not required, we can set the 'required' parameter as 'False'. The default value for required is True.
e.g)
class ReviewForm(forms.Form):
    user_name = forms.CharField(label="Your name", required=False, max_length=100, error_messages={
        "required": "Your name must not be empty!",
        "max_length": "Please enter a shorter name!"
    })

-> To set a textarea, we stick to using the 'forms.CharField()' but we set the 'widget' parameter as 'forms.Textarea'.
e.g)
class ReviewForm(forms.Form):
    user_name = forms.CharField(label="Your name", max_length=100, error_messages={
        "required": "Your name must not be empty!",
        "max_length": "Please enter a shorter name!"
    })
    review_text = forms.CharField(label="Your Feedback", widget=forms.Textarea, max_length=200)

-> To set a field only accepting integer values, we use 'forms.IntegerField()'
e.g)
class ReviewForm(forms.Form):
    user_name = forms.CharField(label="Your name", max_length=100, error_messages={
        "required": "Your name must not be empty!",
        "max_length": "Please enter a shorter name!"
    })
    review_text = forms.CharField(label="Your Feedback", widget=forms.Textarea, max_length=200)
    rating = forms.IntegerField(label="Your Rating", min_value=1, max_value=5)

-> For more information on this topic, check out the official docs
e.g)
https://docs.djangoproject.com/en/5.0/ref/forms/fields/



CUSTOMIZING THE RENDERED HTML:
-> Normally, when we output a form using {{ form }} in the template, the outputted HTML is the label first, error messages second followed by the input fields.
-> If we want to change this order, we can render the individual parts of the form.
-> To access an input field, we can use {{ form.<field_name> }}
-> To access the label of an input field, we can do {{ form.<field_name>.label_tag }}
-> To access the errors for a specific input field, we can do {{ form.<field_name>.errors }}
e.g)
<form action="/" method="POST">
    {% csrf_token %} 
    {{ form.user_name.label_tag }}
    {{ form.user_name }}
    {{ form.user_name.errors }}
    <button>Send</button>
</form>

-> We can place each form control in it's own div to apply different styling for each field.
e.g)
<div class="form-control">
    {{ form.user_name.label_tag }}
    {{ form.user_name }}
    {{ form.user_name.errors }}
</div>

-> We can also add conditional class names to forms in case we want to apply styling in certain conditions.
e.g)
<div class="form-control {% if form.user_name.errors %}errors{% endif %}">
    {{ form.user_name.label_tag }}
    {{ form.user_name }}
    {{ form.user_name.errors }}
</div>



STYLING THE ERRORS:
-> The error list is an <ul></ul> tag containing all the errors which are to be displayed.
-> This <ul></ul> tag is given a default class name of 'errorlist' which we can use to style the <ul></ul> tag however we please.
-> We can also add custom individual styles for each input field by using class names on the divs encompassing an input field. 



DISPLAYING MULTIPLE INPUT FIELDS:
-> To display multiple input fields while also having a specific HTML order of form elements, we can use the {% for %} tag.
e.g)
<form action="/" method="POST">
    {% csrf_token %} 
    {% for field in form %}
        <div class="form-control {% if field.errors %}errors{% endif %}">
            {{ field.label_tag }}
            {{ field }}
            {{ field.errors }}
        </div>
    {% endfor %}
    <button>Send</button>
</form>



STORING FORM DATA IN DATABASE:
-> We add the form data into the database similar to how we did it before and we can access the form data through 'form.cleaned_data["<field_name>"]'.
e.g)
def review(request):
    if request.method == 'POST':
        form = ReviewForm(request.POST)
        if form.is_valid():
            review = Review(user_name=form.cleaned_data["user_name"], review_text=form.cleaned_data["review_text"], rating=form.cleaned_data["rating"])
            review.save()
            return HttpResponseRedirect("/thank-you")
    else:
        form = ReviewForm()
    return render(request, "reviews/review.html", {
        "form": form
    })



MODELFORMS:
-> If we have a form that just accepts values for a model, we can let django create a form based on our model.
-> To connect a model to a form, we do (in the 'forms.py' file)
e.g)
from django import forms
from .models import Review
class ReviewForm(forms.ModelForm):
    class Meta:
        model = Review
        fields = ['user_name', 'review_text', 'rating']

-> The fields property specifies the model fields which we display on the form.

-> In case we want to include all the model fields in the form, we do
e.g)
class ReviewForm(forms.ModelForm):
    class Meta:
        model = Review
        fields = '__all__'

-> In case we want to mention all the fields which we want to exclude from the form instead, we can do
e.g)
class ReviewForm(forms.ModelForm):
    class Meta:
        model = Review
        exclude = ['owner_comment']

-> Labels for ModelForms are autogenerated by default.

-> We can choose to use ModelForms or the conventional way of creating a seperate Model and Form. Both of these methods work and it is only a matter of preference and situation.



CONFIGURING A MODELFORM:
-> If we want to set our own custom labels, we can set a 'labels' property.
-> This 'labels' property is a dictionary whose keys are the field names from the model and values are the label names which we want to provide.
e.g)
class ReviewForm(forms.ModelForm):
    class Meta:
        model = Review
        fields = '__all__'
        labels = {
            'user_name': 'Your Name',
            'review_text': 'Your Feedback',
            'rating': 'Your Rating'
        }

-> We can set our own custom error messages using the 'error_messages' property.
-> This 'error_messages' is a dictionary containing the following structure
e.g)
class ReviewForm(forms.ModelForm):
    class Meta:
        model = Review
        fields = '__all__'
        error_messages = {
            'user_name': {
                'required': 'Your name must not be empty!',
                'max_length': 'Please enter a shorter name'
            }
        }
-> We can add error messages for more input fields similarly if we desire.



SAVING DATA WITH MODELFORMS:
-> Normally, after validating the form, we create a model instance with the entered data and then save it(using 'review.save()') to the database.
e.g)
def review(request):
    if request.method == 'POST':
        form = ReviewForm(request.POST)
        if form.is_valid():
            review = Review(user_name=form.cleaned_data["user_name"], review_text=form.cleaned_data["review_text"], rating=form.cleaned_data["rating"])
            review.save()
            return HttpResponseRedirect("/thank-you")

-> However, while working with ModelForms the process is more simple.
-> All we have to do is 'form.save()'
e.g)
def review(request):
    if request.method == 'POST':
        form = ReviewForm(request.POST)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect("/thank-you")

-> We might have situations where we want to edit (updating) an already present instance of a model with data entered in a form.
-> To do this, we set a parameter 'instance' equal to the model instance which we get.
e.g)
def review(request):
    if request.method == 'POST':
        existing_data = Review.objects.get(pk=1)
        form = ReviewForm(request.POST, existing_data)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect("/thank-you")
-> This will update an already present database instance.



CLASS BASED VIEWS:
-> Up until now, we have only defined views as functions.
-> Views can also however, be defined as classes. Defining views as classes can have some advantages.
-> We can mix up view definitions as well (functions and classes).
-> We primarily do this to get cleaner code wherever a route gets both GET and POST requests.
e.g)
from django.views import View
class ReviewView(View):
    def get(self, request):
        form = ReviewForm()   
        return render(request, "reviews/review.html", {
            "form": form
        })
    def post(self, request):
        form = ReviewForm(request.POST)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect("/thank-you")   
        return render(request, "reviews/review.html", {
            "form": form
        })
-> In the above code, we do not need 'if-else' statements for different request types as django runs the appropriate methods accordingly after we tweak the urls.py file.

-> We tweak the 'urls.py' file as follows
e.g)
urlpatterns = [
    path("", views.ReviewView.as_view()),
    path("thank-you", views.thank_you)  
]
-> The 'as_view()' function is a built in function which lets django know that the class which we defined is a view.
-> The 'as_view()' function also helps django find the get() and post() methods in the class.

-> We can also extend (inherit from) other type of views as well. For more information on these other views, check out the official documentation
e.g)
https://docs.djangoproject.com/en/5.0/topics/class-based-views/generic-display/
-> These different view extensions help us reduce the amount of code to be typed significantly.



TEMPLATE VIEW:
-> This is another type of class view which we could extend(inherit) from.
-> The template view is used to create view classes which return templates.
-> While using the 'TemplateView' we do not need to define a function to return a template. 
-> We rather just have to set a property 'template_name' to the path of the template which we want to display.
-> This will automatically render the template when a GET request is made.
e.g)
from django.views.generic.base import TemplateView
class ThankYouView(TemplateView):
    template_name = "reviews/thank_you.html"

-> To output dynamic content using the 'TemplateView', we override a function called 'get_context_data'.
-> We need to make sure that we always call 'super().get_context_data(**kwargs)'. We do not have to necessarily return it.
-> The result of this call will contain the context(basically a dictionary) which we pass to the template.
-> We can alter this context(dictionary) to add specific keys and values which we want and return it.
e.g)
class ThankYouView(TemplateView):
    template_name = "reviews/thank_you.html"
    def get_context_data(self, **kwargs):
        context =  super().get_context_data(**kwargs)
        context["message"] = "This works!"
        return context



ACCESSING DYNAMIC SEGMENTS OF AN URL USING TEMPLATE VIEW:
-> If we have a dynamic segment in our URL and we want to access it, we can do that using the 'kwargs' parameter of the 'get_context_data' function which we override.
e.g)
class SingleReviewView(TemplateView):
    template_name = "reviews/single_review.html"
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        review_id = kwargs["id"]
        selected_review = Review.objects.get(pk=review_id)
        context["review"] = selected_review
        return context
-> In the above code, "id" should be replaced with the name of our dynamic segment mentioned in the 'urls.py' file.



THE LIST VIEW:
-> This is another type of class view which we could extend(inherit) from. 
-> We use this class view whenever we want to display a list of data.
-> This is pretty much an extension of the 'TemplateView' and helps with displaying a list of data from a specific model.

-> We previously used to do this in the following way
e.g)
from .models import Review
from django.views.generic import ListView
class ReviewsListView(TemplateView):
    template_name = "reviews/review_list.html"
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        reviews = Review.objects.all()
        context["reviews"] = reviews
        return context

-> This is how we can do it using the 'ListView' to reduce the amount of code which we need to write.
e.g)
class ReviewsListView(ListView):
    template_name = "reviews/review_list.html"
    model = Review
-> By default, django fetches all the data from the model which we specify.

-> The data fetched by 'ListView' can be accessed in the template by referring to 'object_list'
e.g)
<ul>
    {% for review in object_list %}
        <li>{{ review.user_name }} (Rating: {{ review.rating }})</li>
    {% endfor %}
</ul>

-> If we want to customize the name of the data being passed into the template however, we can set the 'context_object_name' property to Whatever name we desire.
e.g)
class ReviewsListView(ListView):
    template_name = "reviews/review_list.html"
    model = Review
    context_object_name = "reviews"

-> We can override methods like 'get_ordering()' to change the order in which we get data, 'get_queryset()' to change how the data is fetched, etc.
e.g)
class ReviewsListView(ListView):
    template_name = "reviews/review_list.html"
    model = Review
    context_object_name = "reviews"
    def get_queryset(self):
        base_query = super().get_queryset()
        data = base_query.filter(rating__gt=4)
        return data

-> Setting a property 'ordering' in this class, would help us order the data in ascending or descending order of a specified field.
e.g)
class ReviewsListView(ListView):
    template_name = "reviews/review_list.html"
    model = Review
    ordering = ["-rating"]           # Orders in decreasing order of rating
    context_object_name = "reviews"
    def get_queryset(self):
        base_query = super().get_queryset()
        data = base_query.filter(rating__gt=4)
        return data



THE DETAIL VIEW:
-> This is another type of class view which we could extend(inherit) from.
-> Used for returning a template with a single piece of data, i.e. to display a single database instance.

-> To use the 'DetailView', we first need to set the dynamic section of URL to 'pk' in the 'urls.py' file.
e.g)
urlpatterns = [
    path("", views.ReviewView.as_view()),
    path("thank-you", views.ThankYouView.as_view()),
    path("reviews", views.ReviewsListView.as_view()),
    path("reviews/<int:pk>", views.SingleReviewView.as_view())
]
-> This tells django that the value to be entered in the dynamic section of the URL should be treated as a primary key value.
-> This also works with slugs.
e.g)
urlpatterns = [
    path("", views.ReviewView.as_view()),
    path("thank-you", views.ThankYouView.as_view()),
    path("reviews", views.ReviewsListView.as_view()),
    path("reviews/<slug:slug>", views.SingleReviewView.as_view())
]

-> The class definition for the 'DetailView' is the same as for 'ListView'.
e.g)
from django.views.generic import DetailView
class SingleReviewView(DetailView):
    template_name = "reviews/single_review.html"
    model = Review

-> The dynamic data being passed to the template is usually the same name as the model but in all lowercase.
-> We can also access the information passed to the template by using 'object'.
e.g)
<h1>{{ review.user_name }}</h1>      <!-- we can also use {{ object.user_name }} -->
<p>Rating: {{ review.rating }}</p>     <!-- Name of the model being used here is Review -->
<p>{{ review.review_text }}</p> 



THE FORM VIEW:
-> Class based views written to cater to forms usually have the same structure.
-> This structure is basically a 'get' method to display the form and a 'post' method to handle form submissions.

-> The way we handled this before was
e.g)
class ReviewView(View):
    def get(self, request):
        form = ReviewForm()
        
        return render(request, "reviews/review.html", {
            "form": form
        })
    def post(self, request):
        form = ReviewForm(request.POST)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect("/thank-you")      
        return render(request, "reviews/review.html", {
            "form": form
        })

-> While using the 'FormView' however, we set the 'form_class' property to the form which we want to link the view with.
-> We then set the 'template_name' property as the path to the template which we want to display.
-> Doing both of these takes care of our GET request functionality as well as form validating(displaying errors if the form data is wrong).
e.g)
from django.views.generic.edit import FormView
class ReviewView(FormView):
    form_class = ReviewForm
    template_name = "reviews/review.html"

-> Now, we need to add on is the 'success_url' property which tells django where to redirect to incase it was a valid form submission.
e.g)
class ReviewView(FormView):
    form_class = ReviewForm
    template_name = "reviews/review.html"
    success_url = "/thank-you"

-> We define what we want django to do in the case of a valid form submission by overriding the 'form_valid' method.
-> This method only runs in the case of a valid form submission.
-> All we need to do is add our form submission logic before the return statement(do not change the return statement here).
e.g)
class ReviewView(FormView):
    form_class = ReviewForm
    template_name = "reviews/review.html"
    success_url = "/thank-you"
    def form_valid(self, form):
        form.save()
        return super().form_valid(form)



THE CREATE VIEW:
-> The 'CreateView' reduces the code required for the 'FormView' even more.
-> This view is used when we want the functioning of the 'FormView' but we want a view which automatically saves the form data to the database.

-> We need to mention the model to which the 'CreateView' is referring to using the 'model' property.
e.g)
class ReviewView(CreateView):
    model = Review

-> We do not even need to create a form class in the 'forms.py' file while using this view.
e.g)
class ReviewView(CreateView):
    model = Review
    fields = "__all__"
-> However, creating a form like this does not give us as much flexibility as given by the form classes made in the 'forms.py' file.

-> We can also use form classes provided in the 'forms.py' file as usual but it must be a ModelForm.
e.g)
class ReviewView(CreateView):
    model = Review
    form_class = ReviewForm

-> We now set the 'template_name' and 'success_url' properties to finish off the functionalities for handling GET requests(with rendering templates), form validations, handling POST requests(with redirection) and saving the form data in the database.
e.g)
class ReviewView(CreateView):
    model = Review
    form_class = ReviewForm
    template_name = "reviews/review.html"
    success_url = "/thank-you"



NOTE: We also have 'UpdateView' and 'DeleteView'. Refer to the official documentation for more information.



FILE UPLOADS:
-> Happens through POST requests.
-> The tag we use for file uploads is the <input /> tag with the type set to 'file'.
e.g)
<form action="/profiles/" method="POST">
    {% csrf_token %}
    <input type="file" />
    <button>Upload!</button>
</form>

-> When we have a form with a file input type present in it, we need to add an 'enctype' attribute to it.
-> This 'enctype' attribute should be set to "multipart/form-data"
e.g)
<form action="/profiles" method="POST" enctype="multipart/form-data">
-> This tells the browser that this form, when submitted, will contain a file and this ultimately changes how the request is sent to the server.

-> To access the uploaded files in the 'views.py' file, we use 'request.FILES'.
-> This 'request.FILES' is a dictionary with the keys being the values of the name attributes of the HTML tags. 
e.g)
class CreateProfileView(View):
    def get(self, request):
        return render(request, "profiles/create_profile.html")
    def post(self, request):
        print(request.FILES["image"])     #This will print out the file name(but request.FILES["image"] is not just a file name, it's an object containing full data about the file)
        return HttpResponseRedirect("/profiles")

-> For more information on file uploads, read the official documentation
e.g)
https://docs.djangoproject.com/en/5.0/topics/http/file-uploads/



STORING FILES LOCALLY(NAIVE WAY):
-> We store files locally with normal python file handling.
e.g)
def store_file(file):
    with open("temp/image.jpg", "wb+") as dest:
        for chunk in file.chunks():
            dest.write(chunk)
class CreateProfileView(View):
    def get(self, request):
        return render(request, "profiles/create_profile.html")
    def post(self, request):
        store_file(request.FILES["image"])                  #This will print out the file name(but request.FILES["image"] is not just a file name, it's an object containing full data about the file)
        return HttpResponseRedirect("/profiles")
-> Here, we're accessing small chunks of the file progressively using the 'file.chunks()' function.
-> We can access the entire file content at once and write it directly using 'read()' but in case the file is huge, a lot of memory will be occupied therefore reading it in chunks is more efficient.

-> One more thing we should note is that the path specified "temp/image.jpg" is with respect to the overall project folder.
-> So, if we expect the file to be stored, we must create a 'temp' directory first in the overall project folder.



ADDING A FORM WITH A FILEFIELD:
-> To make a file input field using a form class, we use 'forms.FileField()'.
e.g)
class ProfileForm(forms.Form):
    user_image = forms.FileField()

-> However, when we create a form class instance in the 'views.py' file, we need to provide both 'request.POST' and 'request.FILES' as parameters to check if the form is valid.
-> This is because 'request.FILES' contains the information about the files which we need for basic validation.
e.g)
def store_file(file):
    with open("temp/image.jpg", "wb+") as dest:
        for chunk in file.chunks():
            dest.write(chunk)
class CreateProfileView(View):
    def get(self, request):
        form = ProfileForm()
        return render(request, "profiles/create_profile.html", {
            "form": form
        })
    def post(self, request):
        submitted_form = ProfileForm(request.POST, request.FILES)
        if submitted_form.is_valid():
            store_file(request.FILES["image"])                  #This will print out the file name(but request.FILES["image"] is not just a file name, it's an object containing full data about the file)
            return HttpResponseRedirect("/profiles")
        return render(request, "profiles/create_profile.html", {
            "form": submitted_form
        })



USING MODELS FOR FILE STORAGE:
-> To create a model field for storing files, we use 'models.FileField()'.
e.g)
class UserProfile(models.Model):
    image = models.FileField()

-> This file field wants a file but this file will not be stored in the database.
-> This is because it is a bad practice to store files in the database as it bloats the database and makes it slow.
-> Files should instead be stored on hard drives.

-> Therefore what 'models.FileField()' does is that it takes the file and stores it in our hard drive and only stores the path to that location in the database.
-> To achieve this, we need to set a 'upload_to' parameter as the location where we will store these files.
-> However, this 'upload_to' parameter by default points to the root directory of the operating system.
-> To set this default root directory to inside the django project, we need to add a 'MEDIA_ROOT' string in the 'settings.py' file.
-> This string is an absolute path to which files will be stored in subdirectories of this path.
e.g)
MEDIA_ROOT = BASE_DIR / "uploads"    # In the 'settings.py' file
-> We create a directory called 'uploads' in the overall django project directory.

e.g)
class UserProfile(models.Model):
    image = models.FileField(upload_to="images")
-> All the files uploaded to this model, will be stored in a subdirectory called 'images' in the 'uploads' folder.

-> Now, to save this file in the respective directory, we do
e.g)
class CreateProfileView(View):
    def get(self, request):
        form = ProfileForm()
        return render(request, "profiles/create_profile.html", {
            "form": form
        })
    def post(self, request):
        submitted_form = ProfileForm(request.POST, request.FILES)
        if submitted_form.is_valid():
            profile = UserProfile(image=request.FILES["image"])
            profile.save()
            return HttpResponseRedirect("/profiles")
        return render(request, "profiles/create_profile.html", {
            "form": submitted_form
        })

-> Django also automatically assigns different names to files in case name clashes occur.



USING AN IMAGE FIELD:
-> In some cases, we might only be interested in storing images specifically instead of storing files in general.
-> For these use cases, we can use 'models.ImageField(upload_to=<location>)' in the 'models.py' file.
-> By doing this, django will only accept images and not other documents(pdf, docx, etc).
e.g)
class UserProfile(models.Model):
    image = models.ImageField(upload_to="images")

-> If this gives an error, just run the following on the terminal
e.g)
python -m pip install Pillow

-> We can similarly set the type as 'forms.ImageField()' in the 'forms.py' file.
e.g)
class ProfileForm(forms.Form):
    image = forms.ImageField()



USING A CREATEVIEW FOR THE SAME FUNCTIONALITY:
-> We can use a 'CreateView' with the 'models.ImageField()' to achieve the same functionality but with lesser code.
e.g)
class CreateProfileView(CreateView):
    template_name = "profiles/create_profile.html"
    model = UserProfile
    success_url = "/profiles"
    fields = "__all__"



DISPLAYING UPLOADED FILES:
-> For a model with the following fields
e.g)
class UserProfile(models.Model):
    image = models.ImageField(upload_to="images")

-> To display these uploaded files, we must first fetch all the data objects from the database and pass it onto the template (or use a class view)
e.g)
class ProfilesView(ListView):
    model = UserProfile
    template_name = "profiles/user_profiles.html"
    context_object_name = "profiles"

-> Now, in the template, we can refer to either the 'path' or 'url' property of the model image field.
-> The path property gives us the file system path and is hence wrong for displaying the image through an <image /> tag.
-> To display the image through an <image /> tag, we must therefore access the 'url' property of the model image field.
e.g)
{% for profile in profiles %}
    <li>
        <img src={{ profile.image.url }} />
    </li>
{% endfor %}

-> This does not completely work however, as it fails to serve the uploaded files. We will look at why this happens and how to address this in the following notes section.



SERVING UPLOADED FILES:
-> The files which we try to display on the browser in the previous notes section are not displayed correctly.
-> This happens because django by default, locks down all our folders and does not expose them to our browser for security reasons.
-> The static files (css and javascript files) are exposed to the browser but these are exceptions to this.

-> To fix this, we must do a couple of things.
-> In the 'settings.py' file, we must add a 'MEDIA_URL' string which will be configured as "/<any_url_name>/".
e.g)
MEDIA_URL = "/user-media/"
-> This url can be anything of our choice and it is part of the url which will be exposed to the outside world for accessing the uploaded files.
-> This works similar to static files where the static files from many different apps are combined and added into one single 'static' folder.

-> After this, we must open the global 'urls.py' file and add the following changes.
e.g)
from django.conf.urls.static import static
from django.conf import settings
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('reviews.urls')),
    path('profiles/', include('profiles.urls'))
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

-> The static function helps us serve static files (makes django aware of the folders which should be exposed to the outside world).
-> The static function takes two arguments, the URL which should be used for exposing the files and the path on the file system which holds the actual files.
-> The second argument is a named argument with the name 'document_root'.

-> After all these steps are followed, the uploaded images should be served correctly.



SESSIONS:
-> These are basically just ongoing connections between a client(browser) and server.
-> This means that it lives on even if the browser is closed in between or even if the computer is shut down.
-> A session can be cleared, deleted and reset. Therefore, it is not forever but it is long living.
-> The developer can decide how long the connection can live for.

-> Data stored in a session persists as long as the session is active.
-> An example of this can be the user authentication status.

-> Without sessions, we would have to login everytime we reload the page or close the browser.

-> The django application running on a server, stores the session data and an unique server identifier.
-> Every user of the website has their own session.
-> The session data and unique identifier are stored in session storage, usually a database or file.
-> The client stores a cookie sent by the server, which contains the session identifier.
-> The client sends this cookie with the session identifier to the server and the server looks up the session in the database and sends the session specific data back to the client or does whatever needs to be done with the session data.

-> Django does a lot of the heavy lifting for us when it comes to sessions and all we need to do is configure how the session will behave.



ENABLING AND CONFIGURING SESSIONS:
-> We first need to make sure that 'django.contrib.sessions.middleware.SessionMiddleware', is a part of the MIDDLEWARE list in the 'settings.py' file.
-> We also need to make sure that 'django.contrib.sessions', is a part of the INSTALLED_APPS list in the 'settings.py' file.
-> Both of these should be present by default.

-> We can also add a new setting at the bottom of the 'settings.py' file, called the 'SESSION_COOKIE_AGE'.
-> This defines how long the session cookie will survive with 2 weeks being the default value. We must set this value in seconds.
e.g)
SESSION_COOKIE_AGE = 604800
-> This would set the cookie age to 1 week.



STORING DATA IN SESSIONS:
-> To add data into the session storage, we access the 'request.session[<keyname>]' property.
-> We can use this property to access session data or add data onto the session data storage.
e.g)
class AddFavouriteView(View):
    def post(self, request):
        review_id = request.POST["review_id"]
        fav_review = Review.objects.get(pk=review_id)
        request.session["favourite_review"] = fav_review
        return HttpResponseRedirect("/reviews/" + review_id)

-> Django adds this data to the database and makes sure this data will be available if requests are sent to the server by the particular user.

-> However, doing this will lead us to encounter a "NOT SERIALIZABLE" error which we will look into in the next notes section.



TYPE OF DATA THAT CAN BE STORED IN SESSION STORAGE:
-> Django takes whatever we are storing and serializes it to a format called JSON.
-> The problem with the above code is that we are trying to store a 'Review' object.
-> This model instance object cannot be serialized into JSON as they might contain methods (methods cannot be converted into JSON).
-> Hence we should not store objects in our sessions and should only store primitive values like strings, dictionaries, etc.
-> Therefore, in the above code, it is better to just store the 'review_id' instead of the object since we can just use the review_id to fetch the object later on.
e.g)
class AddFavouriteView(View):
    def post(self, request):
        review_id = request.POST["review_id"]
        request.session["favourite_review"] = review_id
        return HttpResponseRedirect("/reviews/" + review_id)



USING SESSION DATA:
-> We access session data the same way as before, i.e. using 'request.session[<keyname>]'.
e.g)
class SingleReviewView(DetailView):
    template_name = "reviews/single_review.html"
    model = Review
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        loaded_review = self.object
        request = self.request
        favourite_id = request.session["favourite_review"]
        context["is_favourite"] = favourite_id == loaded_review.id
        return context
-> 'self.object' in the above code gives us access to the loaded Review object.
-> 'self.request' gives us access to the request.

-> The above code still does not perfectly work and we need to tweak one single thing.
-> We are originally storing the review_id in the session storage as a string. This is because we get the review_id from the input field and everything recieved from the input field is a string.
-> Therefore when we compare the two ids here 'favourite_id == loaded_review.id', there is a type mismatch.
-> We can fix this however using a simple type cast.
e.g)
class SingleReviewView(DetailView):
    template_name = "reviews/single_review.html"
    model = Review
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        loaded_review = self.object
        request = self.request
        favourite_id = request.session["favourite_review"]
        context["is_favourite"] = favourite_id == str(loaded_review.id)
        return context
-> This above code works perfectly.



SAFELY ACCESSING SESSION DATA:
-> Trying to access any session data may fail if it was not set before.
-> So, if we load the site without any session being set, we will run into an error.
-> Therefore, a safer way to access session data would be to use 'request.session.get("<keyname>")'.
e.g)
class SingleReviewView(DetailView):
    template_name = "reviews/single_review.html"
    model = Review
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        loaded_review = self.object
        request = self.request
        favourite_id = request.session.get("favourite_review")
        context["is_favourite"] = favourite_id == str(loaded_review.id)
        return context



CHOOSING BETWEEN THE DEFAULT AND EXTERNAL DATABASES:
-> SQLite can tend to be slow for larger applications with a lot of incoming requests.
-> Deleting the single SQLite file would result in permanent loss of data.
-> These are two considerations we need to consider if we want to stick to the default SQLite database file or if we want to change to a database server.



CHOOSING BETWEEN NOSQL AND SQL:
-> SQL tends to be a better option here because Django's model system supports it.



DJANGO AND SERVERS:
-> Django is not a webserver.
-> Django is a framework for python which knows how to work with incoming requests and create responses.
-> it does not listen for incoming requests or handle any other server tasks.
-> We need a dedicated web server for that.
-> This is where the wsgi.py and asgi.py files become important.
-> Requests are funneled by the webserver into one of these two files, and the file kicks off the entire application and makes sure Django can deal with the incoming requests.
-> 'wsgi.py' is more commonly used.
-> For more information about Django developement, read the official docs.
e.g)
https://docs.djangoproject.com/en/5.0/howto/deployment/



SERVING STATIC FILES:
-> 'python manage.py runserver' is a deployment-only server which handles static files serving. 
-> However, after deploying, requests for static files and user uploads (basically static files after being uploaded) are not handled by default by Django.
-> This is done to optimize the serving of static files.
-> We can solve this in a couple of ways.

-> The first way is to configure Django to serve such files(using urls.py)
-> This is okay for smaller sites but is not performance optimized.

-> The second and better option is to configure the web server to serve static files and Django app.
-> This is better for performance.

-> The third option is to use a dedicated service/server for static and uploaded files.
-> Initial setup is more complex but offers best performance.



HOSTING PROVIDERS FOR DEPLOYING DJANGO APPLICATIONS:
-> One option for deploying Django applications is 'Digital Ocean'.
-> Another option is 'AWS'.
-> Another option could be 'Vercel'.
-> We could also use 'Render'.



REVISITING SETTINGS:
-> The settings.py file has a 'SECRET_KEY' variable which is used by Django to assign cookies and for security relevant aspects in general.
-> This key should be atleast 32 characters and random.
-> This should be kept and secret and not pushed onto github, etc. Therefore it is generally better to use this as an environment variable.

-> We should also set 'DEBUG' to 'False' as leaving it as True gives a more detailed error output(which we do not want to show to third party visitors).

-> The 'ALLOWED_HOSTS' list contains the domain/domains under which we host our application.

-> We change the 'DATABASES' dictionary, if we change our database from SQLite to something else.

-> For more information on the settings, read the official docs.
e.g)
https://docs.djangoproject.com/en/5.0/topics/settings/



COLLECTING STATIC FILES:
-> Static files are all the files which we ship together with our Django application which are not our templates or python code.
-> Examples are css, javascript, image and other such files.
-> Django should be aware of the locations of the static files so that it can collect them.
-> Django usually collects all static files from all the different apps and adds them in one folder which is served by either django or a dedicated static host.
-> To specify where we want the collected files to be stored, in the 'settings.py' file, we add a 'STATIC_ROOT' variable and set it to a directory where all the static files will be stored.
e.g)
STATIC_ROOT = BASE_DIR / "staticfiles"

-> Do not use the same directory for uploaded files and static files.
-> Users can upload malicious javascript files which can destroy our application.

-> Now to collect all the static files, we use this command.
e.g)
python manage.py collectstatic

-> Do not make changes to the 'staticfiles' directory which contains all the files.
-> Instead, make changes like we did previously during developement.

-> We re-run the above command anytime we make changes to any static files.



CONFIGURING DJANGO TO SERVE STATIC FILES:
-> This is the easiest way to serve static files but not the best.
-> To configure django to serve staticfiles, we do 
e.g)
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('reviews.urls')),
    path('profiles/', include('profiles.urls'))
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) \
  + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)



USING WHITENOISE TO SERVE STATIC FILES:
-> We can also use a third-party solution to serve static files.
-> To install whitenoise, do
e.g)
pip install whitenoise
-> Now, in the settings.py file, add the following line in the 'MIDDLEWARE' list.
e.g)
'whitenoise.middleware.WhiteNoiseMiddleware'



VIRTUAL ENVIRONMENT SETUP:
-> To install virtualenv, do:
e.g)
pip install virtualenv

-> To set up a virtual environment, do:
e.g)
python -m venv <virtualenv_name>

-> To activate the virtual environment, just do: (on bash terminal)
e.g)
source <virtualenv_name>\Scripts\activate 

-> Install all necessary packages after activating the virtual environment.
e.g)
pip install django
django-admin startproject <project_name> .          (This dot creates the django project in the same virtual environment folder)

-> To deactivate the virtual environment, just do:
e.g)
deactivate

-> To create a requirements.txt file, just run:
e.g)
pip freeze > requirements.txt

-> To install these requirements, we do:
e.g)
pip install -r requirements.txt



USING ENVIRONMENT VARIABLES:
-> To use environment variables in python, we do
e.g)
from os import getenv
ALLOWED_HOSTS = [
    getenv("APP_HOST")
]
-> The environment variable which we provide to the hosting operator should be 'APP_HOST' in this case.

-> If we want to provide default values, we can do
e.g)
DEBUG = getenv("IS_DEVELOPMENT", True)



REDIRECTING IN THE MAIN URLS FILE:
-> If in case we need to redirect from a route to another route everytime a certain route is hit, we can use the RedirectView in the main 'urls.py' list.
e.g)
from django.views.generic.base import RedirectView
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', RedirectView.as_view(url='/meetups')),
    path('meetups/', include('meetups.urls))
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)